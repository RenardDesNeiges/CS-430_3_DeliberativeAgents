\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{textcomp}
\usepackage[top=0.8in, bottom=0.8in, left=0.8in, right=0.8in]{geometry}
% Add other packages here %


% Put your group number and names in the author field %
\title{\bf Excercise 3\\ Implementing a deliberative Agent}
\author{Group \textnumero : 272257, 262609}


% N.B.: The report should not be longer than 3 pages %


\begin{document}
\maketitle

\section{Model Description}
The problem studied in this report is once again the pickup and delivery problem. This time, our goal is to implement a deliberative agent. This agent establishes a complete plan before doing anything. The plan is supposed to render the best efficiency in terms of cost to deliver the given tasks. Once the plan is established, the agent will act accordingly. If only one agent is present on the tracks, the agent will execute the plan in its entirety and will stop, as nothing has to be done anymore. If two or more agents are present, it can be that one agent disrupt the plan of the other. What happens in that case is that the agent which finds its plan unexecutable will compute one once again with updated informations about the environement when encountering an undoable action (ex: picking up a contract that has already been picked up by an other agent earlier). To establish the plan, we will use research algorithms \emph{BFS} and \emph{A*} on trees. The nodes of the trees will be implemented by the class \emph{State}.
\subsection{Intermediate States}
% Describe the state representation %
Here we integrated the intermediate states with the following attributes:
\begin{itemize}
	\item[$\bullet$] logist.topology.Topology.City \emph{city}, the city the agent is currently in,
	\item[$\bullet$] LinkedList$<$Task$>$ \emph{ctask}, that represent the list of tasks the agent has picked up. Note that the elements of the list also have 2 attributes : $pickupCity$ that represents the city the agent can pickup the contract at, $deliveryCity$ that represents the city the agent must deliver the contract at, $weight$ that represents the weight of the contract,
	\item[$\bullet$] LinkedList$<$Task$>$ \emph{free\_tasks}, that represents the list of tasks that have not been picked up yet. The elements of the list have the same attributes as in the list mentionned before,
	\item[$\bullet$] State \emph{parent}, that is the predecessor of the current state. This will be used after the application of the \emph{BFS} and \emph{A*} algorithms to build back the plan from the goal state we find using those algorithms,
	\item[$\bullet$] double \emph{cost}, that is equal to the sum of all steps needed to get to the state, 
	\item[$\bullet$] Act \emph{act}, represents the action taken at the given state. This value can vary between \emph{START}, \emph{PICKUP}, \emph{MOVE} and \emph{DELIVER}. The meaning of these actions will be given in a section below.
	\item[$\bullet$] int \emph{depth}, that represents the depth of the nodes in the tree,
	\item[$\bullet$] Boolean \emph{heuristic}, that represents the method used by the search algorithm. If $heuristic=true$, then the \emph{A*} algorithm is used. Otherwise the \emph{BFS} algorithm is used.
\end{itemize}

\subsection{Goal State}
% Describe the goal state %
A goal state is defines as a state at wich all tasks have been picked up and delivered. Translated , this gives the condition $ctask.size() == 0\ \&\&\ free\_tasks.size() == 0$. 

\subsection{Actions}
% Describe the possible actions/transitions in your model %
The agent has 4 different possiblities of action. An action is implemented by the $act$ variable and it defines what the chilren of a node can be. We provide a clearer explanation. Suppose we have a state $state$. We will only give the attributes that change, the rest is assumed to remain constant except for the $parent$ attribute that is set to $state$ and $depth$ that is set to $state.depth+1$ for the child. Note that all combination of mentioned cases can happen and thus we generate a child node for each individual possibility if not mentionned otherwise.
\begin{itemize}
	\item[$\bullet$] \underline{If $state.act=START$:} Then we can have 
		\begin{align*}
			s'.act &= \begin{cases}
					 PICKUP &,\ \mathrm{if}\ state.city\in\{task.pickupCity\ |\ task\in state.free\_tasks\},\\
					 MOVE &,\ \mathrm{in\ any\ case}.
				       \end{cases}
		\end{align*}
		
	\item[$\bullet$] \underline{If $state.act=PICKUP$:} Note that it means that we have that there exists $task\in state.free\_tasks$ such that $task.pickupCity=state.city$. Then we can have 
		\begin{align*}
			s'.ctask =& s.ctask.add(task),\\
			s'.free\_tasks =& s.free\_tasks.remove(task),\\
			s'.act =& \begin{cases}
						PICKUP &,\ \mathrm{if}\ state.city\in\{task.pickupCity\ |\ task\in state.free\_tasks.remove(task)\},\\
						MOVE &,\ \mathrm{in\ any\ case},\\
						DELIVER &,\ \mathrm{if}\ state.city\in\{task.deliveryCity\ |\ task\in state.ctask\}.
					\end{cases}
		\end{align*}
	
	\item[$\bullet$] \underline{If $state.act=DELIVER$:} Note that this means that we have a task $task\in state.ctask$ such that $task.deliveryCity = state.city$. Then we can have
		\begin{align*}
			s'.ctask =& state.ctask.remove(task),\\
			s'.act =& \begin{cases}
						PICKUP &,\ \mathrm{if}\ state.city\in\{task'.pickupCity\ |\  task'\in state.free\_tasks\},\\
						MOVE &,\ \mathrm{in\ any\ case},\\
						DELIVER &,\ \mathrm{if}\ state.city\in\{task.'pickupCity\ |\ task'\in state.ctask.remove(task)\}.
					\end{cases}
		\end{align*}
		
			
	\item[$\bullet$] \underline{If $state.act=MOVE$}:  Then for each $city'$ such that $state.city.isNeighbour(city')$, we can have 
		\begin{align*}
			s'.city =& city',\\
			s'.cost =& state.cost+state.city.distanceTo(city'),\\
			s'.act =& \begin{cases}
						PICKUP &,\ \mathrm{if}\ city'\in\{task.pickupCity\ |\ task\in state.free\_tasks\},\\
						MOVE &,\ \mathrm{in\ any\  case},\\
						DELIVER  &, \mathrm{if}\ city'\in\{task.deliveryCity\ |\ task\in state.ctask\}.
					\end{cases}
		\end{align*}
\end{itemize}
			

\section{Implementation}

\subsection{BFS}
% Details of the BFS implementation %

\subsection{A*}
% Details of the A* implementation %

\subsection{Heuristic Function}
% Details of the heuristic functions: main idea, optimality, admissibility %


\section{Results}

\subsection{Experiment 1: BFS and A* Comparison}
% Compare the two algorithms in terms of: optimality, efficiency, limitations %
% Report the number of tasks for which you can build a plan in less than one minute %

\subsubsection{Setting}
% Describe the settings of your experiment: topology, task configuration, etc. %

\subsubsection{Observations}
% Describe the experimental results and the conclusions you inferred from these results %


\subsection{Experiment 2: Multi-agent Experiments}
% Observations in multi-agent experiments %

\subsubsection{Setting}
% Describe the settings of your experiment: topology, task configuration, etc. %

\subsubsection{Observations}
% Describe the experimental results and the conclusions you inferred from these results %

\end{document}